/* =============================================================================
 * Plot data as graph
 * 
 * differs from graph-hr-version-dev as follows
 * 
 * sizes nodes and text according to weight of node. weight is count of number of
 * edges that a node has and is generated by the use of force layout
 * 
 * ============================================================================= */

//------------------------------------------------------------------------------
//GLOBALS DO NOT CHANGE OR REMOVE
//------------------------------------------------------------------------------

var nodes = [];
var links = [];
var groups = [];
var graphNodes = [];
var graphLinks = [];



var network = {};
var currentNode = {};
var force;
var nodeViews = []; //used a stack so that go to previous visualisation

//******************************************************************************
//ALTER THESE TO ADJUST YOUR GRAPH SETTINGS
//******************************************************************************

var sizingFactor = 1.5; //used to adjust size text and circles along with calculated weight
var linkDistance = 150; //default link length
var charge = -500;
var gWidth = 1200; //graph width in pixels
var gHeight = 1000; //graph height in pixels

var defaultColor = "#000000";
var groupColors = [
    {group: "1", color: "#27ae61"},
    {group: "2", color: "#e84c3d"},
    {group: "3", color: "#c5b3b1"},
    {group: "4", color: "#e37f25"},
    {group: "5", color: "#34495e"},
    {group: "6", color: "#544e15"},
    {group: "7", color: "#ad2673"},
    {group: "8", color: "#08b1f4"}
]

//
//MOVE SOME OF THE FORCE PROPERTIES SO THEY CAN BE SET HERE - THIS WILL ENABLE
//NATHAN AND JOHN TO CONFIGURE HOW THEY WANT THE GRAPH TO TRANSITION BETTER
//




//******************************************************************************
//******************************************************************************
function getGroupColor (group) {
    
    var m = groupColors.filter(function(d) { return d.group == group; });
    
    if (m.length == 0){
        return defaultColor;
    } else {
        return m[0].color;
    }
}


function formatData (csv) {
    
     network = {
         groups: [],
         nodes: [],
         links: []
     }
    
    
     //populate network groups
    var matched;
    var g = d3.nest()
                .key(function(d){ return d.Group1; })
                .entries(csv);
    
    for (var i=0;i<g.length;i++){
        var group = {
            id: g[i].key,
            label: g[i].values[0].Group1Name
        }
        network.groups.push(group);
    }
    
    g = d3.nest()
           .key(function(d){ return d.Group2; })
           .entries(csv);
    
    console.log(g);
    
    for (var i=0;i<g.length;i++){
        matched = false;
        //see if already in
        for (var j=0;j<network.groups.length;j++){
            if (network.groups[j].id == g[i].key) {
                matched = true;
                break;
            }
        }
        
        if (!matched){
            var group = {
                id: g[i].key,
                label: g[i].values[0].Group2Name
            }
            network.groups.push(group);
        }
    }
    
    /* =========================================================================
     * process the nodes
     * ========================================================================= */
    
    var nodeId = 0;
    
    for (var i=0;i<csv.length;i++){
        matched = false;
        for (var j=0;j<network.nodes.length;j++){
            if (csv[i].Connection1 == network.nodes[j].label){
                matched = true;
                break;
            }
        }
        if (!matched){
            nodeId++;
            var n = {
                id: nodeId,
                label: csv[i].Connection1,
                group: csv[i].Group1,
                customValues: []
            }
            n.customValues.push(csv[i].Group1Name);
            network.nodes.push(n);
        }
    }
    
    for (var i=0;i<csv.length;i++){
        matched = false;
        for (var j=0;j<network.nodes.length;j++){
            if (csv[i].Connection2 == network.nodes[j].label){
                matched = true;
                break;
            }
        }
        if (!matched){
            nodeId++;
            var n = {
                id: nodeId,
                label: csv[i].Connection2,
                group: csv[i].Group2,
                customValues: []
            }
            n.customValues.push(csv[i].Group2Name);
            network.nodes.push(n);
        }
    }
    
    /* =========================================================================
     * Do Links
     * ========================================================================= */
    
    for (var i=0;i<csv.length;i++){
        
        var sId = network.nodes.filter(function(d) { return d.label == csv[i].Connection1; })[0].id;
        var tId = network.nodes.filter(function(d) { return d.label == csv[i].Connection2; })[0].id;
        
        var l = {
            source: sId, target: tId, value: "1"
        }
        
        network.links.push(l);
    }
    
    
    console.log("network");
    console.log(network);
    
    //return;
    
    
    
        //make groups
        for (var i=0;i<network.groups.length;i++){
            groups.push({
                id: network.groups[i].id,
                label: network.groups[i].label,
                color: getGroupColor(network.groups[i].id)
            });
        }
    
        //make nodes and links
        for (var i=0;i<network.nodes.length;i++){
            var color = defaultColor;
            if (network.nodes[i].group!==""){
                color = groups.filter(function(d){
                    return d.id == network.nodes[i].group;
                })[0].color;
            }
            var node = {
                id: network.nodes[i].id,
                label: network.nodes[i].label,
                group: network.nodes[i].group,
                color: color,
                customValues: []
            };
            for (var j=0;j<network.nodes[i].customValues.length;j++){
                node.customValues.push(network.nodes[i].customValues[j]);
            }
            
            
            nodes.push(node);
            
        }
    
        //    sortNodes();
    
    
       console.log("Links = " + network.links.length);
       
        for (var i=0;i<network.links.length;i++){
            var source = nodes.filter(function(d){
                return d.id == network.links[i].source;
            })[0];
            var target = nodes.filter(function(d){
                return d.id == network.links[i].target;
            })[0];
            links.push({
                source: source,
                target: target,
                value: network.links[i].value
            });
        }
    
      
       //calculate weight
       for (var i=0;i<nodes.length;i++){
         
         var weight = links.filter(function(d){
                    return d.target.id == nodes[i].id || d.source.id == nodes[i].id;
                }).length;

         nodes[i].xWeight = weight;
       
       };
    
}





function plotGraph(error, data) {
    
    if (!error) {
    
        console.log("csv");
        console.log(data);
    
        
        
       /* ======================================================================
        * Constructed data sets now determine the starting data
        * ====================================================================== */
        
        formatData(data);
        
        /* =====================================================================
           works cos only one node in this group
           ===================================================================== */
        var groupid = "7";
        currentNode = nodes.filter(function(d){ return d.group == groupid; })[0];
        
        //calculate weight
        var weight = links.filter(function(d){
            return d.source.id == currentNode.id;
        }).length;

        currentNode.xWeight = weight;
        
        nodeViews.push(currentNode);
        
        setFilteredNodes(currentNode);
        
        //initialise at earliest stage
        initGraph();
        draw();
        
        
        populateNodeList(graphNodes);
        populateFilter(network.groups, network);
        populateAbout("node",currentNode);
        populateNodeDataTable(graphNodes);
        
        // =====================================================================
        // populate the autocomplete for the search box
        // =====================================================================
        var searchSource = [];
        for (var i=0;i<nodes.length;i++){
            var v = { label: nodes[i].label, value: nodes[i].label, id: nodes[i].id };
            searchSource.push(v);
        }
        
        var settings = {
            minLength: 1,
            source: searchSource,
            select: function( event, ui){
                $("#searchGraph").val(ui.item.label);
                console.log(ui.item);
                
                nodeViews.push(currentNode);
                if (nodeViews.length > 1) {
                    $("#graphBackBtn").removeClass("hidden");
                }
            
                var id = ui.item.id;
                
                currentNode = nodes.filter(function(d){
                    return d.id == id;
                })[0];
            
                setFilteredNodes(currentNode);
                //reload data ino graph
                force.nodes(graphNodes)
                force.links(graphLinks);
                draw(); 
                populateNodeList(graphNodes);
                populateAbout("node",currentNode);
                populateNodeDataTable(graphNodes);
            }
        }
        
        $("#searchGraph").autocomplete(settings);
        
    }
}

function initGraph() {
    
    //ADDED
    $("#graph").empty();
    
    //$("a.navbar-brand").text(network.label);
    
    //calculate height based on number of nodes
    //gWidth = network.graphConfig.size.width;
    //gHeight = network.graphConfig.size.height;
 

    var zoom = d3.behavior.zoom()
    .scaleExtent([1, 10])
    .on("zoom", zoomed);

    svg = d3.select("#graph").append("svg")
    .attr("xmlns","http://www.w3.org/2000/svg")
    .attr("xml:lang", "en")
    .attr("class", "graph")
    //.attr("width", gWidth + "px") changed to this to make a bit more responsive
    .attr("width", "100%")
    .attr("height", gHeight + "px")
    .append("g")
        .attr("transform", "translate(0,0)")
        .call(zoom);
        
      
             
    //alter these to affect layout
    /* =================================================================
     * ORIGINAL SETTINGS
     * ================================================================= */
    force = d3.layout.force()
    .nodes(graphNodes)
    .links(graphLinks)
    .gravity(.1) //originally .2
    .charge(charge)
    //.charge(-700)
    .distance(linkDistance) //changed from 120
    //.linkDistance(network.graphConfig.linkDistance) //changed from 120
    .linkDistance(linkDistance)
    .size([gWidth, gHeight])
    //.friction(0.4) //added
    //.theta(0.8) //added
    //.alpha(0.01) //added
    //.on("tick", tick);
    
            
    svg.append("rect")
    .attr("id", "background")
    .attr("class", "background")
    .attr("width", gWidth)
    .attr("height", gHeight)
    //added
    .style("pointer-events", "all")
    .on("click", function() {
        
        //fade in all nodes and links
        d3.selectAll(".link").style("opacity", 1);
        d3.selectAll(".node").style("opacity", 1);
                  
    });
    
    function zoomed() {
        svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }
    
}


function draw() {  
        
        
        //sortNodes();
        
        var link = svg.selectAll(".link");
        var node = svg.selectAll(".node");
        
        
        link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
        
        link.enter().insert("line", ".node").attr("class", "link")
        //.attr("class", "link")
        .attr("id", function(d){ return "link-" + d.source.id + "-" + d.target.id; })
        .attr("source-id", function(d){ return d.source.id; })
        .attr("target-id", function(d){ return d.target.id; })
        .style("stroke-dasharray", "2,2")
        .style("stroke-width", 1.4);
        
        link.append("title")
                .text(function(d) {
                    return d.source.label + " " + d.value + " " + d.target.label;
                });
        
        link.exit().remove();

        node = node.data(force.nodes(), function(d) { return d.id;});
        
        var g = node.enter().append("g")
              .attr("class",function(d){ return "node group" + d.group; })
              .attr("id", function(d) { return "node-" + d.id; })
              .attr("node-id", function(d) { return d.id; })
              .attr("group-id", function(d) { return d.group; })
              .on("click", function(d){
                
                if (d3.event.defaultPrevented) return; // click suppressed
                
                nodeViews.push(currentNode);
                if (nodeViews.length > 1) {
                    $("#graphBackBtn").removeClass("hidden");
                }
                
                console.log("node clicked");
                var id = d.id;
                currentNode = nodes.filter(function(d){ return d.id == id; })[0];
                
                /* not quite right here */
                setFilteredNodes(currentNode);
               
//                console.log("new graph nodes");
//                console.log(graphNodes);
//                console.log("new graph links");
//                console.log(graphLinks);
                
                //reload data ino graph
                force.nodes(graphNodes)
                force.links(graphLinks);
                draw(); 
                
                populateNodeList(graphNodes);
                populateAbout("node",currentNode);
                populateNodeDataTable(graphNodes);
                
                
              })
              .on("mouseover", function(d){
                  //highlight this node
                  d3.selectAll(".link").style("opacity", .1);
                  d3.selectAll(".node").style("opacity", .1);
                  d3.select("#node-" + d.id).style("opacity", 1);
              })
              .on("mouseout", function(){
                  //fade in all nodes and links
                  d3.selectAll(".link").style("opacity", 1);
                  d3.selectAll(".node").style("opacity", 1);
              })
              .on("dragstart", function(){
                  d3.event.sourceEvent.stopPropagation(); 
              })
              .on("dragend", function(){
                  d3.event.sourceEvent.stopPropagation(); 
              })
              .call(force.drag);
        /* ==============================================================
         * radius changed from default 5 to based on weight
         * changed to use xWeight
         * ============================================================== */
        var circle = g.append("circle")
                .attr("r", function(d){
                    return Math.round(Math.sqrt(d.xWeight)) * sizingFactor;
                })
                .style("fill", function(d){ return d.color; })
                .style("stroke", "#fff");
               
        var text = g.append("text")
                    .text(function(d, i) {
                        return d.label;
                    });
//                        if (i == 0) {
////                        if (d.id == currentNode.id) {
//                            console.log("root node " + d.label);
//                            return d.label;
//                        } else {
//                            if (d.xWeight > 1) {
//                                return d.label + "+";
//                            } else {
//                                return d.label;
//                            }
//                        } });
                    
        node.exit().remove();
        
        force.on("tick", function() {
            
            //console.log("tick fired");
            
            //for g as node
            node.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
//            node.attr("cx", function(d) { return d.x; })
//                .attr("cy", function(d) { return d.y; })

            link.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });
       
           /* ==================================================
            * altered from default -9,9
            * 
            * CHANGED FROM WEIGHT TO XWEIGHT
            * ================================================== */
           text.attr("dy", ".35em")
            .attr("dx", function(d) {
                if (d.x <= gWidth / 2) {
                    return - (Math.round(Math.sqrt(d.xWeight)) * sizingFactor) - 5;
                } else {
                    return (Math.round(Math.sqrt(d.xWeight)) * sizingFactor) + 5;
                }
            })
            .style("text-anchor", function(d) {
                if (d.x <= gWidth / 2) {
                    return "end";
                } else {
                    return "start";
                }
            })
            .style("font-size", function(d){
                return (.4 + (d.xWeight * (sizingFactor / 100))) + "em";
            });
                                 
                    
    });
    
    force.start();     
}


function populateFilter(groups, network){
    
    sortGroups();
    
    var v = $("#filterNodes");
    var t = v.find("li:first");
    t.unbind("click");
    
    
    if (groups.length > 0) {
        v.find("li").remove();
    }
    
    for (var i=0;i<groups.length;i++){
        var li = t.clone(true);
        
        li.css("margin-left","2px");
        li.css("margin-bottom","2px");
        li.css("border-left",groups[i].color + " 5px solid");
        
        li.attr("group-id", groups[i].id);
        var a = li.find("a");
        //var nodeCount = network.nodes.filter(function(d){ return d.group == groups[i].id; }).length
        //a.text(groups[i].label + " (" + nodeCount + ")");
        a.text(groups[i].label);
        //add event
        li.click(function(e){
            e.preventDefault();
            var id = $(this).attr("group-id");
            currentGroup = groups.filter(function(d){ return d.id == id; })[0];
            filterNodes(id);
            populateAbout("group", currentGroup);
        });
                
        v.append(li);
        
    }
    
    
}



function populateNodeList(nodes){
    
    var v = $("#nodeList");
    var t = v.find("li:first");
    t.unbind("click");
       
    v.find("li").remove();
    
    
    for (var i=0;i<nodes.length;i++){
        var li = t.clone(true);
        
        li.css("margin-left","2px");
        li.css("margin-bottom","2px");
        li.css("border-left",nodes[i].color + " 5px solid");
        
        var a = li.find("a");
        a.attr("node-id", nodes[i].id)
        a.text(nodes[i].label);
        
        a.click(function(e){
            
            
            e.preventDefault();
            nodeViews.push(currentNode);
            if (nodeViews.length > 1) {
                $("#graphBackBtn").removeClass("hidden");
            }
            
            var id = d3.select(this).attr("node-id");
            currentNode = nodes.filter(function(d){ return d.id == id; })[0];
            
            setFilteredNodes(currentNode);
            //reload data ino graph
            force.nodes(graphNodes)
            force.links(graphLinks);
            draw(); 
            populateNodeList(graphNodes);
            populateAbout("node",currentNode);
            populateNodeDataTable(graphNodes);
            
        })
        
        v.append(li);
    }
    
    
}

function populateAbout(level, obj) {
    
    //console.log("populate about using...")
    //console.log(obj);
    
    var props = [];
    var u = $("#aboutList");
    var l = u.find("li:first");
    u.find("li").remove();
    
    
    props.push(obj.label);
    
    //replaces code below
    $("#aboutList li:eq(0)").text(obj.label)
    
    
    
    if (level == "node"){
        for (var i=0; i<obj.customValues.length;i++){
             if (obj.customValues[i]!==""){
                props.push(obj.customValues[i]);
             }
        }
    }
    
    for (var i=0;i<props.length;i++){
            var li = l.clone(true);
            li.html(props[i]);
            u.append(li);
        
    }
    

} 


function populateNodeDataTable (nodes) {
    
    $("#dataLinks").addClass("hidden");
    $("#dataNodes").removeClass("hidden");
    
    //console.log(nodes);
    
    var tb = $("#dataNodeTable tbody");
    var tr = $("#dataNodeTable tbody tr:first");
       
    tb.find("tr").remove();
    
    for (var i=0;i<nodes.length;i++) {

        var r = tr.clone(true);
        r.find("td:eq(0)").text(i + 1);
        r.find("td:eq(1)").text(nodes[i].label);
        
        tb.append(r);
    }
}


//function searchNodes (val) {
//    
//    var matchedNodes = [];
//    
//    if (val !== "") {
//      //match nodes
//        //var matchedNodes = nodes.filter(function(d) { return d.label.match(new RegExp(val, "i")); }); 
//        
//        matchedNodes = nodes.filter(function(d) { 
//          if (d.label.match(new RegExp(val, "i"))) {
//            return d.label.match(new RegExp(val, "i")); 
//          } else {
//            for (var i=0; i < d.customValues.length; i++) {
//                if (d.customValues[i].match(new RegExp(val, "i"))) {
//                    return d.customValues[i].match(new RegExp(val, "i"));
//                }
//            }
//          }
//        }); 
//        
//        console.log("matching nodes on " + val);
//        console.log(matchedNodes);
//        d3.selectAll(".link").style("opacity", .1);
//        d3.selectAll(".node").style("opacity", .1);
//        for (var i=0;i<matchedNodes.length;i++) {
//            d3.select("#node-" + matchedNodes[i].id).style("opacity", 1);
//        }
//        
//    } else {
//        
//        d3.selectAll(".link").style("opacity", 1);
//        d3.selectAll(".node").style("opacity", 1);
//        
//    }
//    
//    populateNodeDataTable(matchedNodes);
//    
//}

function filterNodes(groupId){
    
    resetNodeText(); 
    
    //highlight nodes assigned to this group
    d3.selectAll(".node").each( function(){
        var nodeGroup = d3.select(this).attr("group-id");
        if (nodeGroup == groupId){
            d3.select(this).style("opacity", 1);
        } else {
            d3.select(this).style("opacity", .1);
        }
    });
    
    d3.selectAll(".link")
    .style("opacity", .1);
    
    //var matchedNodes = graphNodes.filter(function(d) { return d.group == groupId; });
    //populateNodeDataTable(matchedNodes);
}



function setFilteredNodes (currentNode) {
    
    graphNodes = [];
    
    graphNodes.push({
                id: currentNode.id,
                label: currentNode.label,
                group: currentNode.group,
                color: currentNode.color,
                customValues: currentNode.customValues,
                xWeight: currentNode.xWeight
            });
    
    var c = graphNodes[0];
    graphLinks = [];
    
    var flinks = links.filter(function(d){
                    return d.source.id == c.id || d.target.id == c.id;
            });
    
//    var flinks = links.filter(function(d){
//                    return d.source.id == currentNode.id;
//            });
            
    for (var i=0; i<flinks.length; i++) {
        
        var s = {
                id: flinks[i].source.id,
                label: flinks[i].source.label,
                group: flinks[i].source.group,
                color: flinks[i].source.color,
                xWeight: flinks[i].source.xWeight,
                customValues: flinks[i].source.customValues
       }
        
       var t = {
                id: flinks[i].target.id,
                label: flinks[i].target.label,
                group: flinks[i].target.group,
                color: flinks[i].target.color,
                xWeight: flinks[i].target.xWeight,
                customValues: flinks[i].target.customValues
       }
       
      //graphLinks.push({source: s, target: t, value: 1});
       
      if (s.id !== currentNode.id) { 
           graphNodes.push(s);
           graphLinks.push({source: s, target: c, value: 1});
      }
      if (t.id !== currentNode.id) { 
           graphNodes.push(t);
           graphLinks.push({source: c, target: t, value: 1});
      }
    }
    
    // *********************************************************************
    // Do links exist between the secondary nodes 
    // *********************************************************************
    
    /*
    for (var i=0;i<graphNodes.length;i++) {
        
        //get this nodes links other links
        var otherLinks = links.filter(function(d) {
            return d.source.id == graphNodes[i].id || d.target.id == graphNodes[i].id;
        });
        
        // process these links
        for (var j=0;j<otherLinks.length;j++){
            
            //if it linked to current node then ignore
            if (otherLinks[j].source.id !== currentNode.id || otherLinks[j].target.id !== currentNode.id) {
                
                var otherNodes = graphNodes.filter(function(d){ return d.id !== graphNodes[i].id; });
                
                for (var k=0;k<otherNodes.length;k++){
                    
                   // if (graphNodes[k].id !== graphNodes[i].id) {
                        
                        if (otherLinks[j].source.id == otherNodes[k].id || otherLinks[j].target.id == otherNodes[k].id){
                            
                            
//                            var s2 = graphNodes.filter(function(d) { 
//                               return d.id = otherLinks[j].source.id;
//                            })[0];
//                            
//                            var t2 = graphNodes.filter(function(d) { 
//                               return d.id = otherLinks[j].target.id;
//                            })[0];
                            
                            // add to links
                            var s2 = {
                                id: otherLinks[j].source.id,
                                label: otherLinks[j].source.label,
                                group: otherLinks[j].source.group,
                                color: otherLinks[j].source.color,
                                xWeight: otherLinks[j].source.xWeight,
                                customValues: otherLinks[j].source.customValues
                            }
        
                            var t2 = {
                                id: otherLinks[j].target.id,
                                label: otherLinks[j].target.label,
                                group: otherLinks[j].target.group,
                                color: otherLinks[j].target.color,
                                xWeight: otherLinks[j].target.xWeight,
                                customValues: otherLinks[j].target.customValues
                            }
       
       
                            var link = {source: s2, target: t2, value: 1};
                            
                            
                            //console.log(graphLinks.indexOf(link));
                            if (graphLinks.indexOf(link) == -1){
                                graphLinks.push(link);
                            }
       
                        }
                        
                   // }
                    
                }
                
            }
            
            
        }
        
        
    }
    
    * ============================================================================
    * ============================================================================ */
    
    console.log("Current Node");
    console.log(currentNode);
    
    console.log("graph nodes");
    console.log(graphNodes);
    console.log("graph links");
    console.log(graphLinks);
    
   // return nodeLinks;
    
}



function resetNodeText () {
    
    //reset text
    d3.selectAll("g.node text").text(function(d){
                          return d.label;
    });
}


function sortNodes() {
   //sort node
    network.nodes.sort(function(a, b){
        var nameA=a.label.toString().toLowerCase().trim(), nameB=b.label.toString().toLowerCase().trim();
        if (nameA < nameB) //sort string ascending
            return -1; 
        if (nameA > nameB)
            return 1;
        return 0; //default return value (no sorting)
    });
}

function sortGroups() {
    groups.sort(function(a, b){
        var nameA=a.label.toString().toLowerCase().trim(), nameB=b.label.toString().toLowerCase().trim();
        if (nameA < nameB) //sort string ascending
            return -1; 
        if (nameA > nameB)
            return 1;
        return 0; //default return value (no sorting)
    });
}